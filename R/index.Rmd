---
title: "Geospatial Characteristics of Program Beneficiaries"
author: "[BACOU, Melanie](http://github.com/mbacou) for [AgResults](http://agresults.org/) (Abt Associates)"
date: "Last updated on `r Sys.Date()`. DO NOT USE OR CITE"
description: "Biophysical, socio-economic, and market information derived from high-resolution remote sensing and modeled time series."
site: bookdown::bookdown_site
knit: bookdown::render_book
output:
  bookdown::gitbook:
    url: "https://mbacou.github.io/2017-agresults/"
    github-repo: "mbacou/2017-agresults"
df_print: paged
always_allow_html: yes
bibliography: biblio.bib
cover-image: fig/cover.jpg
csl: apa.csl
link-citations: yes
nocite: |
  @mathew2016drought, @santiago2016speibase
---

# Survey Sampling

```{r setup, include=F}

library(raster)
library(data.table)
library(tables)
library(tmap)
library(viridis)
library(knitr)
library(stringr)
library(curl)

load("../tmp/2017-agresults.RData")

# Output options
opts_chunk$set(comment=NA, warning=F, message=F, echo=F, base.url="../docs",
  dev="png", fig.path="fig/", fig.width=7, fig.height=3.8, dpi=300, cache=F, 
  dev.args=list(
    png=list(family="Roboto Condensed", pointsize=9), 
    svg=list(family="Roboto Condensed")))
table_options(htmloptions(justification="c", head=F, pad=T))

```


```{r nga, eval=FALSE}

load("./tmp/2017-agresults.RData")

#####################################################################################
# Helper - Pirate Plot Defaults
pplot <- function(..., note=NULL, alpha=.1) {
  require(yarrr)
  pirateplot(..., pal="black", jitter.val=.07,
    cex.names=.8, cex.axis=.8, gl.lty=3, back.col="white",
    point.o=min(alpha, .1), point.pch=16, point.cex=.5,
    bean.f.col="white", bean.lwd=.2,
    inf.lwd=.2, inf.f.col="blue", inf.f.o=.3,
    quant=.5, quant.col="limegreen", quant.lwd=1.2, quant.length=.9,
    avg.line.col="red", avg.line.lwd=1.2)
  if(!missing(note)) title(main=sprintf("Missing or null: %4.0f%%", note), 
    adj=.99, col.main="grey10", cex.main=.8, font.main=1, line=.5)
}
#####################################################################################
# Helper - Color Palettes
pal.rain <- fread("
224	255	255	Light cyan
135	206	235	Sky blue
30	144	255	Dodger blue
0	0	205	Medium blue
20	113	61	Camarone
60	179	113	Medium sea green
143	188	143	Dark sea green
240	230	140	Khaki
244	164	96	Sandy brown
178	34	34	Firebrick
  ")
pal.rain <- rgb(pal.rain[, .(V1, V2, V3)], maxColorValue=255)
pal.rain <- colorRampPalette(pal.rain)

pal.et <- fread("
245	114	0
245	169	29
252	210	111
204	204	204
211	255	190
152	230	0
56	169	0
  ")
pal.et <- rgb(pal.et[, .(V1, V2, V3)], maxColorValue=255)
pal.et <- colorRampPalette(pal.et)

pal.et_anom <- fread("
245	145	31	Lightning yellow
246	169	30	Supernova
252	211	112	Salomie
205	204	204	Blue zodiac
214	232	186	Snow flurry
158	203	59	Atlantis
54	170	73	Forest green
  ")
pal.et_anom <- rgb(pal.et_anom[, .(V1, V2, V3)], maxColorValue=255)
pal.et_anom <- colorRampPalette(pal.et_anom)

pal.spei <- fread("
245	145	31	Lightning yellow
246	169	30	Supernova
252	211	112	Salomie
205	204	204	Blue zodiac
214	232	186	Snow flurry
158	203	59	Atlantis
54	170	73	Forest green
  ")
pal.spei <- rgb(pal.spei[, .(V1, V2, V3)], maxColorValue=255)
pal.spei <- colorRampPalette(pal.spei)

pal.pet <- fread("
219	189	117	Marzipan
230	204	150	Chamois
240	219	184	Champagne
247	232	204	Varden
255	255	212	Light goldenrod
240	255	176	Australian mint
222	255	173	Reef
199	255	140	Mantis
128	255	8	Chartreuse
51	255	0	Green
13	194	0	Lime green
0	156	33	Forest green
0	128	135	Teal
0	92	125	Orient
  ")
pal.pet <- rgb(pal.pet[, .(V1, V2, V3)], maxColorValue=255)
pal.pet <- colorRampPalette(pal.pet)

pal.ndvi <- fread("
182	151	99	Barley corn
209	189	139	Double colonial white
230	233	187	Spring sun
181	219	142	Reef
133	201	97	Mantis
78	157	38	Apple
39	111	0	La palma
40	97	0	Bilbao
30	75	0	Chelsea cucumber
  ")
pal.ndvi <- rgb(pal.ndvi[, .(V1, V2, V3)], maxColorValue=255)
pal.ndvi <- colorRampPalette(pal.ndvi)

pal.ndvi_anom <- fread("
120	81	12	Buttered rum
151	112	59	Muddy waters
176	147	107	Muesli
206	194	177	Stark white
222	222	222	Gainsboro
177	201	167	Spring rain
121	172	106	Gossip
76	150	65	Bilbao
31	128	22	Forest green
  ")
pal.ndvi_anom <- rgb(pal.ndvi_anom[, .(V1, V2, V3)], maxColorValue=255)
pal.ndvi_anom <- colorRampPalette(pal.ndvi_anom)

pal.ndvi_pct <- fread("
115	76	0	Buttered rum
214	111	43	Tango
237	161	19	Supernova
245	202	12	Turbo
255	255	135	Dolly
224	224	224	Athens grey
136	204	102	Mantis
59	163	88	Chateau green
26	125	117	Surfie green
22	103	138	Boston blue
11	44	122	Dark slate blue
  ")
pal.ndvi_pct <- rgb(pal.ndvi_pct[, .(V1, V2, V3)], maxColorValue=255)
pal.ndvi_pct <- colorRampPalette(pal.ndvi_pct)

pal.temp <- fread("
253	229	253	Thistle
252	61	251	Fuchsia
98	1	254	Blue
61	160	252	Havelock blue
49	251	139	Medium spring green
126	254	0	Chartreuse
252	223	0	Gorse
239	112	1	Dark orange
126	0	1	Dark red
  ")
pal.temp <- rgb(pal.temp[, .(V1, V2, V3)], maxColorValue=255)
pal.temp <- colorRampPalette(pal.temp)

#####################################################################################
# Nigeria Locations
#####################################################################################
# Load NGA coords
nga.hh <- fread("./data/GIS Coordinates for Mel.csv")
setnames(nga.hh, c("hhid", "calc_state", "calc_lga", "calc_village", "Y", "X"))

# Impute missing with LGA centroid
nga.l2 <- shapefile("~/Google Drive/2016-BMGF-Segmentation/NGA/maps/admin/g2015_2014_2_NGA.shp")

# Reproject
nga.l2 <- spTransform(nga.l2, CRS("+init=epsg:4326"))

# LGA Centroids
nga.l2.pts <- data.table(coordinates(nga.l2))
setnames(nga.l2.pts, c("X", "Y"))
nga.l2.pts <- cbind(nga.l2.pts, nga.l2@data[, c(9,10,5,6,1,2)])

# Check names against micro data
setkey(nga.l2.pts, ADM2_NAME)
setkey(nga.hh, calc_lga)
nga.hh[!nga.l2.pts, unique(calc_lga), by=calc_state]
#    calc_state           V1
# 1:     Kaduna Birnin-Gwari -> Birnin Gwari
# 2:     Kaduna       Chukun -> Chikun
# 3:    Katsina        Kahur -> Kafur (Katsina), verified in QGIS
# 4:       Kano   Tudun Wada -> Tundun Wada

nga.hh[, .N, keyby=.(calc_state, calc_lga)]
tmp <- nga.l2.pts[, .N, keyby=.(ADM1_NAME, ADM2_NAME)]

# Recodes
nga.l2.pts[, svyL2Nm := factor(ADM2_NAME)]
levels(nga.l2.pts$svyL2Nm)[c(109,139,397,709)] <- c("Birnin-Gwari", "Chukun", "Kahur", "Tudun Wada")
setkey(nga.l2.pts, svyL2Nm)
setkey(nga.hh, calc_lga)
nga.hh[!nga.l2.pts, unique(calc_lga), by=calc_state]
# Empty data.table (0 rows) of 2 cols: calc_state,V1 => OK

# Impute NAs with centroids
nga.hh[nga.l2.pts, `:=`(calc_lga_X=i.X, calc_lga_Y=i.Y)]
nga.hh[is.na(calc_lga_X), .N]
nga.hh[, `:=`(X_imp=X, Y_imp=Y)]
nga.hh[is.na(X*Y), `:=`(X_imp=calc_lga_X, Y_imp=calc_lga_Y)]

# Also recode LGA map
nga.l2$svyL2Nm <- factor(nga.l2@data$ADM2_NAME)
levels(nga.l2$svyL2Nm)[c(109,139,397,709)] <- c("Birnin-Gwari", "Chukun", "Kahur", "Tudun Wada")

# Check to make sure existing coords fall in expected LGA
nga.pts <- SpatialPointsDataFrame(nga.hh[, .(X_imp,Y_imp)], data.frame(nga.hh),
  proj4string=CRS("+init=epsg:4326"))

nga.hh <- data.table(extract(nga.l2, nga.pts))
nga.hh <- cbind(nga.odd, nga.pts@data)
setcolorder(nga.hh, c(30:39, 1:29))
nga.hh <- nga.hh[, .SD, .SDcols=c(1:10,13,14,17:18,21,22,29)]
setnames(nga.hh, 11:17, tolower(names(nga.hh)[11:17]))
nga.odd <- nga.hh[calc_lga != svyL2Nm]
# => need to map these

# Update map
nga.pts <- SpatialPointsDataFrame(nga.hh[, .(X_imp,Y_imp)], data.frame(nga.hh),
  proj4string=CRS("+init=epsg:4326"))

# Export to STATA
nga.odd <- nga.odd[, .SD, .SDcols=c(1,3:4,7:8,11:12,20:25, 28:29)]
setcolorder(nga.odd, c(1,8:11,13,12,14,15,2:7))
setattr(nga.odd, "var.labels", 
  c("location id", "household id", "state", "LGA", "village", "longitude", "latitude",
    "longitude (imputed with centroid)", "latitude (imputed with centroid)",
    "GAUL LGA code", "GAUL LGA name", "GAUL state code", "GAUL state name",
    "GAUL country code", "GAUL country name"))
write.dta(nga.odd, "./out/2017-abt-nga_odd.dta", version=12L, convert.factors="string")

# Make and save map
tmp <- nga.pts[nga.odd$hhid %in% nga.odd$hhid,]

m.nga <- tm_shape(nga.l2) +
  tm_polygons(fill="grey90", border.col="grey80", alpha=.2) + 
  tm_shape(tmp, is.master=T, projection="eck4") +
  tm_dots(col="calc_lga", shape=4, alpha=.5, legend.show=T, size=.3,
    title="Nigeria\nSurveyed\nHousehold\nLocations\n(invalid)") +
  tm_shape(nga.l2) +
  tm_text("svyL2Nm", col="grey30", size="AREA", root=4) +  
  tm_scale_bar(position=c("left", "bottom"), breaks=c(0,20,40,60)) +
  tm_layout(legend.outside=T)

save_tmap(m.nga, "./out/2017-abt-nga_odd.pdf", width=5, units="in")

```

```{r ken, eval=FALSE}

#####################################################################################
# Kenya Locations
#####################################################################################
# 2017.07.03: received corrected admin details from Betsy
# 2017.07.01: received admin details but file is no good
# 2017.07.01: asked Katie for a recent map of Kenya's subcounties

# This survey includes 2 rounds of data collection with replacements
# so some hhlds are only present in round #1 and some in round #2.
# The general imputation approach is:
# 1) if both GPS locations seem valid, then use middle point 
# 2) if only 1 of the 2 locations is valid, use that one 
# 3) if no location is valid (both fall outside of that unit), use the unit centroid

# Load KEN coords
ken.hh <- read.dta("./data/gis_kenya_for consultant.dta")
ken.hh <- data.table(ken.hh)

# Codebook from MSExcel
ken.lbl <- fread("
varCode	varLabel
HHID	Unique household identifier
GPS_LA	GPS measurement from baseline data collection round 1
GPS_LO	GPS measurement from baseline data collection round 1
BL2_GPS_LA	GPS measurement from baseline data collection round 2
BL2_GPS_LO	GPS measurement from baseline data collection round 2
A01	Region
A02	County
A03	Subcounty
A04	Location
A05	Sublocation
A06	Village
BL2_A01	Region (baseline data collection round 2)
BL2_A02	County  (baseline data collection round 2)
BL2_A03	Subcounty (baseline data collection round 2)
BL2_A04	Location (baseline data collection round 2)
BL2_A05	Sublocation (baseline data collection round 2)
BL2_A06	VIllage (baseline data collection round 2)
  ")

# Keep only what I need
ken.hh <- ken.hh[, .SD, .SDcols=ken.lbl$varCode]
setnames(ken.hh, tolower(names(ken.hh)))
ken.lbl[, varCode := tolower(varCode)]

# Validate admin details
# Missing?
ken.hh[is.na(X), .N]
# [1] 30

# Merge survey labels into Kenya county map `ken.l2`

# Validate all locations

# Use the latest county map from CELL5M
load("~/Projects/hc-cell5m/rdb/g2.rda")
ken.l2 <- g2[g2$ADM0_NAME=="Kenya",]
# Has 47 counties from the new constitution
rm(g2)

# Reproject
ken.l2 <- spTransform(ken.l2, CRS("+init=epsg:4326"))

# Verify the status/version of this map
ken.l2.pts <- data.table(ken.l2@data)
setnames(ken.l2.pts, tolower(names(ken.l2.pts)))
ken.l2.pts[, rn := row.names(ken.l2)]

# County centroids
tmp <- data.table(coordinates(ken.l2))
setnames(tmp, c("X", "Y"))
ken.l2.pts <- cbind(tmp, ken.l2.pts)

# Check to make sure existing coords fall in expected county
ken.pts <- SpatialPointsDataFrame(ken.hh[!is.na(X), .(X,Y)], data.frame(ken.hh[!is.na(X)]),
  proj4string=CRS("+init=epsg:4326"))

tmp <- data.table(extract(ken.l2, ken.pts))
tmp <- cbind(tmp[, c(3:8)], ken.pts@data)

# Merge admin details back into `ken.hh`
setnames(tmp, tolower(names(tmp)))
setkey(tmp, hhid)
setkey(ken.hh, hhid)
ken.hh <- tmp[, .SD, .SDcols=1:7][ken.hh]
setcolorder(ken.hh, c(7:13, 6,3,5,2,4,1))


# Impute loc_status, X_imp, Y_imp
# Use coords from round #2 if available, else round #1
ken.hh[, X := ifelse(is.na(bl2_gps_lo), gps_lo, bl2_gps_lo)]
ken.hh[, Y := ifelse(is.na(bl2_gps_la), gps_la, bl2_gps_la)]




# Export to STATA
setattr(ken.hh, "var.labels", 
  c("household id",
    "latitude (round #1)", "longitude (round #1)",
    "latitude (round #2)", "longitude (round #2)",
    "longitude (for mapping)", "latitude (for mapping)",
    "GAUL county code", "GAUL county name", "GAUL province code", "GAUL province name",
    "GAUL country code", "GAUL country name"))
write.dta(ken.hh, "./out/2017-abt-ken_hh.dta", version=12L, convert.factors="string")

# Make and save maps
ken.pts <- SpatialPointsDataFrame(ken.hh[!is.na(X), .(X,Y)], data.frame(ken.hh[!is.na(X)]),
  proj4string=CRS("+init=epsg:4326"))
ken.pts$adm2_name <- factor(as.character(ken.pts$adm2_name))

m.ken <- tm_shape(ken.l2) +
  tm_polygons(fill="grey90", border.col="grey80", alpha=.2) + 
  tm_shape(ken.pts, is.master=T, projection="eck4") +
  tm_dots(col="adm2_name", shape=4, alpha=.5, size=.3,
    legend.show=T, max.categories=24,
    title="Kenya\nSurveyed\nHousehold\nLocations") +
  tm_shape(ken.l2) +
  tm_text("ADM2_NAME", col="grey30", size="AREA", root=4) +
  tm_scale_bar(position=c("left", "bottom"), breaks=c(0,20,40,60,80)) +
  tm_layout(legend.outside=T)

save_tmap(m.ken, "./out/2017-abt-ken_hh.pdf", width=7, units="in")

# Also save county and coords for QGIS
shapefile(ken.l2, "./maps/ken-abt-17_L2.shp")
shapefile(ken.pts, "./maps/ken-abt-17_hh.shp")




```


```{r uga, eval=FALSE}

#####################################################################################
# Uganda Locations
#####################################################################################


```

```{r save, eval=FALSE}

rm(tmp, x, i)
save.image("./tmp/2017-agresults.RData")

```

**Abstract**  
We derive climatic, biophysical, socio-economic, and market-based information using a variety of sources, high-resolution remote sensing, and modeled time series.

--------------------------------------------------------------------------------------

The tables and maps below provide detailed spatially-referenced characteristics of farm households interviewed as part of AgResults 2015-2017 baseline and endline surveys in Nigeria, Kenya, and Uganda.

All statistics are derived using the geospatial locations of surveyed respondents. However these locations are sometimes missing or invalid. In the case of missing coordinates we collect spatial statistics at the centroid of the matching administrative unit (the lowest level unit that may be mapped with any confidence, i.e. LGA for Nigeria, county for Kenya, and district for Uganda). Note that another approach would be to derive average statistics over the entire administrative unit, however this approach is more resource-intensive.

## Nigeria

**`r format(nrow(nga.hh), big.mark=",")`** households are sampled in Nigeria. There are **`r nga.hh[is.na(X), .N]`** households missing coordinates and **`r nrow(nga.odd)` possibly invalid** locations.

```{r nga-na, results="asis"}

# How many NAs?
tmp <- nga.hh[, .(`Obs.`=.N, Missing=sum(is.na(X)), Invalid=sum(calc_lga!=svyL2Nm)),
  keyby=.(State=calc_state, LGA=calc_lga)]

table_options(HTMLcaption="(#tab:nga-na) Survey Sampling across LGAs and missing Household Locations")
html(tabular(Factor(State)*(Factor(LGA)*DropEmpty()+1)+1~Heading("Nigeria Household GPS Locations")*(`Obs.`+Missing+Invalid)*Format(big.mark=",")*Heading()*sum, data=tmp),
  rmarkdown=T)

```

There are **`r nrow(nga.odd)` households** with GPS coordinates that do not fall within their recorded LGA. In the majority of instances the distance is negligeable (under 10km) and this might not affect any of the spatial estimates. In a few instances the errors are troublesome (over 40km). For documentation purposes households with problematic locations are highlighted on the map below.


```{r nga-odd, fig.cap="Households with Invalid GPS Locations, Nigeria", fig.height=6, fig.width=6}

# Are all locations in the correct LGA
tmap_mode("plot")
m.nga

```

## Kenya

In Kenya data was collected over 2 rounds with some attrition, and household locations do not necessarily match across rounds. We use a general approach to impute missing and/or conflicting coordinates:

1) if both GPS locations seem valid, we use the middle point   
2) if only 1 of the 2 locations is valid, we use that one   
3) if no location is valid (both fall outside of a recorded administrative unit), we use this unit centroid.  

**`r format(nrow(ken.hh), big.mark=",")` households** are sampled in Kenya. There are **`r ken.hh[is.na(gps_la), .N]`** households missing coordinates and **` nrow(ken.odd)` possibly invalid** locations. Details in the table below.


```{r ken-na, eval=F, results="asis"}

# How many NAs?
tmp <- ken.hh[, .(N=.N, miss=sum(is.na(X))), 
  keyby=.(adm1_name=as.character(adm1_name), adm2_name=as.character(adm2_name))]
tmp[is.na(adm1_name), `:=`(adm1_name=" N/A", adm2_name=" N/A")]

table_options(HTMLcaption="(#tab:ken-na) Survey Sampling across Counties and missing Household Locations")
html(tabular((`Province`=Factor(adm1_name))*((`County`=Factor(adm2_name))*DropEmpty()+1)+1~Heading("Kenya Household GPS Locations")*(Heading("Obs.")*N+Heading("Missing")*miss)*Format(big.mark=",")*Heading()*sum, data=tmp), rmarkdown=T)

```


```{r ken-hh, fig.cap="Households Locations across Counties, Kenya", fig.height=6, fig.width=6}

# Are all locations in the correct LGA
tmap_mode("plot")
m.ken

```

## Uganda

[in progress]

**` format(nrow(uga.hh), big.mark=",")` households** are sampled in Uganda. There are **` uga.hh[is.na(X), .N]`** households missing coordinates and **` nrow(uga.odd)` possibly invalid** locations.



